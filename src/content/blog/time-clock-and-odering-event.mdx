---
title: Thời gian và thứ tự event trong hệ thống phân tán
summary: Tổng quan về thời gian, các loại clock và việc đảm bảo thứ tự trong hệ thống phân tán
postLayout: column
date: '2024-10-04'
draft: false
cover: '@/assets/time-in-distributed-system/cover.png'
tags: [distributed-system]
---
import Figure from "@/components/Figure.astro"
import ntpExample from "@/assets/time-in-distributed-system/ntp.png"
import orderingProblem from "@/assets/time-in-distributed-system/ordering-problem.png"
import happensBeforeExample from "@/assets/time-in-distributed-system/happens-before-example.png"


## Vai trò của thời gian trong hệ thống phân tán
Hệ thống phân tán thường dùng thời gian để:

- Lập lịch, timeout, kiểm tra lỗi, retry …
- Đo đạc thông tin hiệu suất, hiệu năng, thống kê, profiling, …
- Log file, database: ghi lại những sự kiện xảy ra tại thời điểm
- Xác định thứ tự của các event giữa các node trong hệ thống.

Thường được chia thành 2 loại clock:

- **Clock vật lý (Physical clocks)**: đếm số giây đã trôi qua
- **Clock logic (Logical clocks)**: đếm số event

## Clock Synchronization và Monotonic Clock
### Clock synchronization
Máy tính theo dõi thời gian vật lý/UTC với đồng hồ thạch anh (quartz) 
(cục pin ở CMOS cấp nguồn điện cho nó luôn hoạt động kể cả máy tính tắt).
Do thời gian trôi dần trong khi đồng hồ không thể luôn giữ chính xác thời gian nên lỗi đồng hồ tăng dần.

&rarr; **Solution**: Định kì lấy thời gian hiện tại từ máy chủ có nguồn thời gian chính xác hơn (GPS).

## Network Time Protocol (NTP)
Là một giao thức để đồng bộ đồng hồ của các hệ thống máy tính thông qua mạng dữ liệu chuyển mạch gói với độ trễ biến đổi.

Phương thức hoạt động:
- NTP client gửi một gói tin, trong đó chứa một thẻ thời gian tới cho NTP server.
- NTP server nhận được gói tin, gửi trả lại NTP client một gói tin khác, có thẻ thời gian là thời điểm nó gửi gói tin đó đi.
- NTP client nhận được gói tin đó, tính toán độ trễ, dựa và thẻ thời gian mà nó nhận được cùng với độ trễ đường truyền, NTP client sẽ set lại thời gian của nó.

<Figure src={ntpExample} alt="">Ví dụ thứ tự thực hiện khi NTP gửi request đến server</Figure>

## Monotonic và time-day-of clocks
### Monotonic clock
- Thời gian tính từ 1 thời điểm bất kì (VD: khi bật máy lên)
- Luôn luôn tăng dần với tốc độ gần như không đổi.
- Hữu ích khi dùng để đo thời gian trôi qua trên 1 node duy nhất.
- Trong LINUX: `clock_gettime(CLOCK_MONOTONIC)`

### Time-day-of clock
- Thời gian tính từ 1 điểm cố định (phổ biến nhất là 01/01/1970, Golang tính từ 02/01/2006)
- Có thể đột ngột tăng dần hoặc giảm dần (NTP stepping), có thể điều chỉnh giây nhuận.
- Timestamp có thể được so sánh giữa các node (nếu được đồng bồ hoá)
- LINUX: `clock_gettime(CLOCK_REALTIME)`

## Vấn đề về thứ tự với thời gian trong hệ thống phân tán
<Figure src={orderingProblem} alt="">Ví dụ về thứ tự với thời gian giữa 3 user</Figure>
Từ hình trên ta có nhận xét:
- 3 người dùng A, B, C
- A gửi tin nhắn `m1` đến B và C
- Khi B nhận được tin nhắn `m1` của A, B nhắn trả lời cho A và C với tin nhắn `m2`.
- Tuy nhiên, trong quá trình gửi tin, tin nhắn của A đến C chậm hơn so với tin nhắn của B đến C. 
Lúc này tại C, tin nhắn `m2` sẽ đến trước tin nhắn `m1`.

&rarr; Kết quả tại C là không rõ ràng, C sẽ thấy phản hồi trước khi thấy cả câu hỏi. 
Và C nghĩ rằng B có siêu năng lực nhìn trước tương lai (lol).

Đó là trong trường hợp thực tế, còn trong trường hợp về mặt kĩ thuật, ta giả định như sau:
- `m1` là 1 lệnh tạo ra 1 object trong cơ sở dữ liệu.
- `m2` là 1 lệnh cập nhật dữ liệu của object đã tạo ở trên.
- Nếu như `m1` đến sau `m2`, ta sẽ thực hiện lệnh cập nhật, tuy nhiên ta dễ thấy không thể cập nhật 
một bản ghi trên một object chưa tồn tại. Điều này chỉ có thể thực hiện khi mà `m1` được thực hiện trước `m2` ⇒ Lỗi.

Vậy làm thế nào để C biết chính xác được m1 được gửi trước m2, hay nói cách khác là thứ tự của các event.

Ta có các cách giải quyết ban đầu như sau:
#### Sử dụng monotonic clock
Với các thành phần nằm trên cùng một node, ta dễ dàng xử lý vấn đề này. Tuy nhiên, trong hệ thống phân tán,
các thành phần lại nằm trên các node khác nhau dẫn đến vấn đề vẫn chưa được giải quyết &rarr; Loại

#### Sử dụng time-of-day clock
Bằng cách gửi kèm timestamp mỗi khi gửi 1 event ⇒ clock synchronization thực hiện bởi Network Time Protocol 
và các protocol tương tự luôn để lại một vài thứ không chắc chắn về sự sai lệch chính xác giữa 2 clock, 
đặc biệt là nếu độ trễ mạng theo 2 hướng bất đối xứng. Lấy ví dụ như sau:
- A gửi m1 với timestamp t1 theo clock của A.
- Khi B nhận được m1 từ A tại thời điểm t2 (tính theo clock của B) với t2 < t1. 
Dễ thấy clock của A đi trước của B một chút nhưng nếu đúng thì phải là t2 > t1 vì m1 đã được gửi 
trước khi được nhận ⇒ Vẫn xảy ra khả năng sai thứ tự.

&rarr; Loại

## Happens-before relation
Ta quy ước một event là một thứ gì đó xảy ra tại 1 node (gửi hoặc nhận một message, hoặc là 1 bước thực thi ở local).

Ta nói event A xảy ra trước event B (A → B) khi nằm ở 1 trong 3 điều kiện sau:
- A và B ở cùng 1 node và thứ tự của A được thực thi trước B ở local.
- event A là event gửi đi một vài message là m đi, và event B là người nhận được message giống với m.
- Tồn tại một event C sao cho A → C và C → B (bắc cầu)
- Có thể xảy ra trường hợp cả A → B và B → A đều không đúng. Với trường hợp này, ta gọi A và B là đồng thời (A || B)
<Figure src={happensBeforeExample} alt="">Ví dụ về quan hệ Happens-before</Figure>
Nhìn vào ảnh trên ta có:
- a → b, c → d, và e → f do cùng nằm trên một node và là thực thi ở local.
- b → c và d → f do `m1` và `m2`
- a → c, a → d, a → f, b → d, b → f, và c → f do tính chất bắc cầu
- a || e, b || e, c || e, và d || e

Mối quan hệ happens-before là một cách lý luận về quan hệ nhân quả trong các hệ thống phân tán.
Quan hệ nhân quả xem xét liệu thông tin có thể đã truyền từ một sự kiện này sang sự kiện khác hay không, 
và do đó liệu một sự kiện có thể đã ảnh hưởng đến sự kiện khác hay không.

Trên đây là tổng hợp thông tin về sự quan trọng của thời gian về thứ tự trong hệ thống phân tán. Giải quyết được
vấn đề về thứ tự event luôn được đảm bảo trong hệ thống phân tán luôn là một bài toán khó khi có nhiều yếu tố tác động
dẫn đến sự sai lệch, bất đối xứng thời gian giữa các node với nhau.

Đây cũng là bài viết mình muốn chia sẻ để có thể làm tiền đề cho những chương mình dự định sẽ viết tiếp theo sau này.
Ở bài sau, hi vọng mình sẽ làm rõ được phần còn lại là Logical Clock cùng với sự quan trọng của nó trong giao thức Broadcast.
Nếu có thắc mắc hay đóng góp nội dung chỉnh sửa, vui lòng liên hệ mình để có thể trao đổi và cập nhật. 
Mình rất welcome các bạn ^^.